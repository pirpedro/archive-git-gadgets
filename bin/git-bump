#!/bin/bash

# this script will display the current version, automatically
# suggest a "minor" version update, and ask for input to use
# the suggestion, or a newly entered value.

# once the new version number is determined, the script will
# pull a list of changes from git history, prepend this to
# a file called CHANGELOG.md (under the title of the new version
# number), give user a chance to review and update the changelist
# manually if needed and create a GIT tag.

#git scritp variables
SUBDIRECTORY_OK="yes"
USAGE=`cat << EOF
[OPTIONS] [INCREMENT] [BRANCH]

  INCREMENT
    Optional parameter that change the increment in version.
    The default version format is 'major.minor.patch' with
    minor increments if the parameter was not mentioned.

  OPTIONS

         --hotfix       Inform that a new hotfix branch will
                        be created. Increment by 'patch' if
                        no parameter was passed.

    -i | --interactive  Use interactive mode.

    -p | --push         Push to remote the current changes.

    -r | --release      Inform that a new release branch will
                        be created.

    -R | --recursive    Recursive find/replace git project by version
                        pattern.

    -v | --version      Specify your own version number for the bump.

EOF`

source "$(git --exec-path)/git-sh-setup"

NOW="$(date +'%B %d, %Y')"
COLOR_RED="\033[1;31m"
COLOR_GREEN="\033[1;32m"
COLOR_YELLOW="\033[1;33m"
COLOR_BLUE="\033[1;34m"
COLOR_PURPLE="\033[1;35m"
COLOR_CYAN="\033[1;36m"
COLOR_WHITE="\033[1;37m"
COLOR_RESET="\033[0m"

QUESTION_FLAG="${COLOR_GREEN}?"
WARNING_FLAG="${COLOR_YELLOW}!"
NOTICE_FLAG="${COLOR_CYAN}❯"

VERSION_FILE=$(git rev-parse --show-toplevel)/.version
CHANGELOG_FILE=$(git rev-parse --show-toplevel)/CHANGELOG.md
TEMP_FILE=$(git rev-parse --show-toplevel)/tmpfile

while [[ "$#" -gt 0 ]]; do
  if [[ "$1" != -* ]]; then break; fi
  key="$1"; shift;
  if [[ ! -z $1 && "$1" != -* ]]; then value="$1"; fi
  case $key in
    -c|--commit)
      COMMIT=true
      ;;
    --hotfix)
      HOTFIX=true
      ;;
    -i|--interactive)
      INTERACTIVE=true
      ;;
    -p|--push)
       PUSH=true
  #    PUSH_BRANCH=${value}
  #    test -z $value || shift
      ;;
    -r|--release)
      RELEASE=true
      ;;
    -R|--recursive)
      RECURSIVE=true
      ;;
    -v|--version)
      if test -z $value; then
        echo "You need to pass version number"; exit 1;
      else
        PARAM_VERSION=${value}; shift;
      fi
      ;;
    # Unknown option. No need for an error, getopts informs
    # the user itself.
    *) usage; exit 1;
  esac
done

if [[ "$1" != -* ]]; then
  case "$1" in
    major|minor|patch )
      INCREMENT="$1"; shift;
      ;;
  esac
fi
if [[ "$1" != -* ]]; then TARGET_BRANCH="$1"; fi
TARGET_BRANCH=${TARGET_BRANCH:-`git rev-parse --abbrev-ref HEAD | cut -d'/' -f 2`}

LATEST_HASH=`git log --pretty=format:'%h' -n 1`

if [[ ! -f $VERSION_FILE ]]; then
  if [[ ! -z "$INTERACTIVE" ]]; then
    echo -e "${WARNING_FLAG} Could not find a .version file."
    echo -ne "${QUESTION_FLAG} Do you want to create a version file and start from scratch? [${COLOR_WHITE}y${COLOR_GREEN}]: "
    read RESPONSE
    if [[ "$RESPONSE" == "" || "$RESPONSE" == "Y" || "$RESPONSE" == "Yes" || "$RESPONSE" == "yes" || "$RESPONSE" == "YES" ]]; then RESPONSE="y"; fi
  else
    RESPONSE="y"
  fi
  if [ "$RESPONSE" = "y" ]; then
      echo "${PARAM_VERSION:-0.0.0}" > $VERSION_FILE
      echo "" > $CHANGELOG_FILE
      echo -e "$NOTICE_FLAG Created '.version' and 'CHANGELOG.md' files in project root."
  else
    exit 1;
  fi
fi

BASE_STRING=`cat $VERSION_FILE`
BASE_LIST=(`echo $BASE_STRING | tr '.' ' '`)
V_MAJOR=${BASE_LIST[0]}
V_MINOR=${BASE_LIST[1]}
V_PATCH=${BASE_LIST[2]}
test -z "$INTERACTIVE" || echo -e "${NOTICE_FLAG} Current version: ${COLOR_WHITE}$BASE_STRING"
test -z "$INTERACTIVE" || echo -e "${NOTICE_FLAG} Latest commit hash: ${COLOR_WHITE}$LATEST_HASH"

if [[ ! -z "$HOTFIX" && -z $INCREMENT ]]; then INCREMENT=patch; fi
INCREMENT=${INCREMENT:-minor}
case "$INCREMENT" in
  major )
    V_MAJOR=$((V_MAJOR + 1)); V_MINOR=0; V_PATCH=0;
    ;;
  minor )
    V_MINOR=$((V_MINOR + 1)); V_PATCH=0;
    ;;
  patch )
    V_PATCH=$((V_PATCH + 1));
    ;;
esac
SUGGESTED_VERSION="${PARAM_VERSION:-$V_MAJOR.$V_MINOR.$V_PATCH}"

if [[ ! -z "$INTERACTIVE" ]]; then
  echo -ne "${QUESTION_FLAG} Enter a version number [${COLOR_WHITE}$SUGGESTED_VERSION${COLOR_GREEN}]: "
  read INPUT_STRING
  if [ "$INPUT_STRING" != "" ]; then
      SUGGESTED_VERSION = $INPUT_STRING
  fi
fi
echo -e "${NOTICE_FLAG} Will set new version to be ${COLOR_WHITE}$SUGGESTED_VERSION${COLOR_GREEN}."

if [[ ! -z "$INTERACTIVE" && -z "$HOTFIX" && -z "$RELEASE" ]]; then
  echo -ne "${QUESTION_FLAG} Create new branch? [[${COLOR_WHITE}n${COLOR_GREEN}]o|[${COLOR_WHITE}h${COLOR_GREEN}]otfix|[${COLOR_WHITE}r${COLOR_GREEN}]elease]: "
  read new_branch
  case "$new_branch" in
    [hH]* )
      HOTFIX=true
      ;;
    [rR]* )
      RELEASE=true
      ;;
  esac
fi
if [[ ! -z "$HOTFIX" ]]; then
  NEW_BRANCH=hotfix/$SUGGESTED_VERSION
elif [[ ! -z "$RELEASE" ]]; then
  NEW_BRANCH=release/$SUGGESTED_VERSION
fi

if [[ ! -z "$INTERACTIVE" && (! -z "$HOTFIX"  || ! -z "$RELEASE") ]]; then
  echo -ne "${QUESTION_FLAG} Enter new branch name [${COLOR_WHITE}$NEW_BRANCH${COLOR_GREEN}]: "
  read new_branch_name
  if [[ "$new_branch_name" != "" ]]; then
    NEW_BRANCH = "$new_branch_name"
  fi
fi

if [[ ! -z "$NEW_BRANCH" ]]; then
  git checkout -b $NEW_BRANCH $TARGET_BRANCH
fi

#handling the version number changes

if [[ -z "$RECURSIVE" && ! -z "$INTERACTIVE" ]]; then
  echo -en "${QUESTION_FLAG} Recursively replace version number in project? [${COLOR_WHITE}yY${COLOR_GREEN}]: "
  read recursively
  case "$recursively" in
    [Nn]* )
      #do nothing
      ;;
    *)
      RECURSIVE=true
      ;;
  esac
fi
if [[ ! -z "$RECURSIVE" ]]; then
  git grep -lw "$BASE_STRING" -- `git rev-parse --show-toplevel` | grep -v CHANGELOG.md | xargs -I {} sh -c "sed -i '' "s/$BASE_STRING/$SUGGESTED_VERSION/g" {}; git add {}"
else
  echo $SUGGESTED_VERSION > $VERSION_FILE
  git add $VERSION_FILE
fi

echo "## $SUGGESTED_VERSION ($NOW)" > $TEMP_FILE
if [[ ! -z `git show-ref --tags | grep "refs/tags/v$BASE_STRING"` ]]; then
  git log --pretty=format:"  - %s" "v$BASE_STRING"...HEAD >> $TEMP_FILE
else
  git log --pretty=format:"  - %s" >> $TEMP_FILE
fi
echo "" >> $TEMP_FILE
echo "" >> $TEMP_FILE
cat $CHANGELOG_FILE >> $TEMP_FILE
mv $TEMP_FILE $CHANGELOG_FILE
if [[ ! -z "$INTERACTIVE" ]]; then
  echo -e "${QUESTION_FLAG} Now you can make adjustments to ${COLOR_WHITE}CHANGELOG.md${COLOR_GREEN}. Then press enter to continue."
  git_editor $CHANGELOG_FILE
fi

git add $CHANGELOG_FILE

if [[ ! -z "$INTERACTIVE" && -z "$COMMIT" ]]; then
  echo -ne "${QUESTION_FLAG} Commit and create tag to branch? [${COLOR_WHITE}Yy${COLOR_GREEN}]: "
  read answer_commit
  case "$answer_commit" in
    [Nn]* )
      ;;
    *)
      COMMIT=true
      ;;
  esac
fi

if [[ ! -z "$INTERACTIVE" && -z "$PUSH" ]]; then
  echo -ne "${QUESTION_FLAG} Push changes to ${COLOR_WHITE}$TARGET_BRANCH${COLOR_GREEN} branch? [${COLOR_WHITE}Yy${COLOR_GREEN}]: "
  read answer_push
  case "$answer_push" in
    [Nn]* )
      ;;
    *)
      PUSH=true
      ;;
  esac
fi

if [[ ! -z "$PUSH" || ! -z "$COMMIT" ]]; then
  git commit -m "Bump version to ${SUGGESTED_VERSION}."
  git tag -a -m "Tag version ${SUGGESTED_VERSION}." "v${SUGGESTED_VERSION}"
fi
if [[ ! -z "$PUSH" ]]; then
  git checkout $TARGET_BRANCH
  if [[ ! -z $NEW_BRANCH ]]; then git merge --no-ff $NEW_BRANCH; fi
  git push origin $TARGET_BRANCH
  git push origin --tags
  echo -e "${NOTICE_FLAG} Pushing new version to the ${WHITE}origin${CYAN}..."

fi
