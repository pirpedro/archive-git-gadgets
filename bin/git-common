#!/bin/bash

source $(git stats --script-location $0)/sh-common
#source $(git --exec-path)/git-sh-setup

parse_before_config(){
    echo "$1" | sed 's/\//-/g'
}

git_get(){ git config --get --file $(git stats --root-path)/.git/gadgets $(parse_before_config $1); }
git_set(){
  git config --file $(git stats --root-path)/.git/gadgets $(parse_before_config $1) "$2";
}
git_unset(){ git config --unset --file $(git stats --root-path)/.git/gadgets $(parse_before_config $1); }
git_unset_all(){ git config --unset-all $(git stats --root-path)/.git/gadgets $(parse_before_config $1);}

gadgets_is_initialized(){
  git rev-parse --git-dir >/dev/null 2>&1 && $(git_get core.master >/dev/null 2>&1)
}

git_is_initialized(){
  gadgets_is_initialized && \
  $(git config --get-regexp --file $(git stats --root-path)/.git/gadgets $(parse_before_config $1) >/dev/null 2>&1)
}

gadgets_flow_is_initialized(){
  git_is_initialized flow
}

gadgets_bump_is_initialized(){
  git_is_initialized bump
}

git_remote_exists(){
  git remote | grep origin > /dev/null
}

git_local_branch_exists(){
  [ -n "$1" ] || die "git_local_branch_exists: No branch name passed."
  [ -n "$(git for-each-ref --format='%(refname:short)' refs/heads/$1)" ]
}

git_remote_branch_exists(){
  [ -n "$1" ] || die "git_remote_branch_exists: No branch name passed."
  [ -n "$(git for-each-ref --format='%(refname:short)' refs/remotes/$1)" ]
}

git_branch_exists(){
  [ -n "$1" ] || die "git_branch_exists: No branch name passed."
  git_local_branch_exists "$1" || git_remote_branch_exists "$ORIGIN/$1"
}

git_tag_exists(){
  [ -n "$1" ] || die "No tag name passed."
  [ -n "$(git for-each-ref --format='%(refname:short)' refs/tags/$1)" ]
}

git_remote_tag_exists(){
  [ -n "$1" ] || die "No tag name passed."
  if git_remote_exists && empty_output git ls-remote refs/tags/$1; then
    return 1
  else
    return 0
  fi
}

git_tag_delete(){
  [ -n "$1" ] || die "git_tag_delete: No tag name."
  git_local_tag_delete "$1"
  git_remote_tag_delete "$1"
}

git_local_tag_delete(){
  [ -n "$1" ] || die "git_local_tag_delete: No tag name."
  git tag -d "$1" >/dev/null 2>&1
}

git_remote_tag_delete(){
  [ -n "$1" ] || die "git_remote_tag_delete: No tag name."
  ! git_remote_tag_exists "$1" || git push origin --delete "$1" >/dev/null 2>&1
}

git_remote_branch_delete(){
  [ -n "$1" ] || die "git_remote_branch_delete: No branch name passed."
  if git_remote_branch_exists "$ORIGIN/$1"; then
    git push "$ORIGIN" :"$1" || die "Not possible to delete remote branch $1 in $origin"
  else
    warn "Remote branch $1 doesn't exists."
  fi
}

ADD_ARRAY=()
git_add(){
  [ "$#" != 0 ] || die "No files to be added."
  git add "$@" >/dev/null && ADD_ARRAY+=("$@")
}

git_commit(){
  [ -n "$1" ] || die "No extension name passed."
  [ -n "$2" ] || die "No message passed."
  git commit -m "[$1] $2" ${ADD_ARRAY[*]} >/dev/null
  ADD_ARRAY=()
}

git_config_has_master(){
  local master=$(git_get core.master)
  [ "$master" != "" ] && git_local_branch_exists "$master"
}

git_config_has_develop(){
  local develop=$(git_get flow.branch.develop)
  [ "$develop" != "" ] && git_local_branch_exists "$develop"
}

gadgets_load_settings(){
  if gadgets_is_initialized; then
    export ORIGIN=$(git_get core.origin || echo origin)
    export MASTER_BRANCH=$(git_get core.master)
    export CURRENT_BRANCH=$(git stats --long-current-branch)
  fi
}

git_local_branches(){ git for-each-ref --sort refname --format='%(refname:short)' refs/heads; }
git_remote_branches(){ git for-each-ref --sort refname --format='%(refname:short)' refs/remotes; }
git_branchs(){ git for-each-ref --sort refname --format='%(refname:short)' refs/remotes refs/heads; }
git_tags(){ git for-each-ref --format='%(refname:short)' refs/tags; }

git_local_branches_with_prefix(){
  [ -n "$1" ] || die "Prefix missing."
  git for-each-ref --format='%(refname:short)' refs/heads/$1\*
}

git_remote_branches_with_prefix(){
  [ -n "$1" ] || die "Prefix missing."
  git for-each-ref --format='%(refname:short)' refs/remotes/\*/$1\*
}

git_branchs_with_prefix(){
  git for-each-ref --format='%(refname:short)' refs/remotes/\*/$1\* refs/heads/$1\*
}

git_is_empty_repo(){
  [ $(find .git/objects -type f -print -quit | wc -c) -eq 0 ]
}

git_checkout(){
  local branch current_branch
  [ -n "$1" ] || die "git_checkout: No branch name passed."
  branch="$1"
  current_branch=${2:-$(git stats --long-current-branch)}
  git fetch --all -p >/dev/null 2>&1 # get last remote changes, to keep consistence

  if ! git_local_branch_exists "$branch"; then
    if git_remote_branch_exists "$ORIGIN/$branch"; then
      git branch "$branch" "$ORIGIN/$branch" >/dev/null 2>&1
    elif git_local_branch_exists "$current_branch"; then
      git branch "$branch" "$current_branch" >/dev/null 2>&1
    fi
  fi
  git checkout "$branch" >/dev/null 2>&1
}

git_editor() {
	if test -z "${GIT_EDITOR:+set}"
	then
		GIT_EDITOR="$(git var GIT_EDITOR)" || return $?
	fi

	eval "$GIT_EDITOR" '"$@"'
}

gadgets_init(){
  local master branch_count suggestion
  for arg do
    shift
    case "$arg" in
      --defaults) set_global_flag defaults; ;;
      -f|--force) set_global_flag force; ;;
      *) set -- "$@" "$arg"; ;;
    esac
  done

  if ! flag defaults; then
    set_global_flag interactive
    verbosity on
  fi

  #set flag to resolve git commit message in the end of function.
  gadgets_is_initialized || set_flag new_gadgets_repo

  if gadgets_is_initialized && ! flag force; then
    warn -f "Git gadgets is already initialized."
    exit 1
  fi

  flag force || flag defaults ||  cat <<EOF
*   _____          _____   _____ ______ _______ _____   *
*  / ____|   /\   |  __ \ / ____|  ____|__   __/ ____|  *
* | |  __   /  \  | |  | | |  __| |__     | | | (___    *
* | | |_ | / /\ \ | |  | | | |_ |  __|    | |  \___ \   *
* | |__| |/ ____ \| |__| | |__| | |____   | |  ____) |  *
*  \_____/_/    \_|_____/ \_____|______|  |_| |_____/   *
*                                                       *
EOF

  flag force || note "Welcome to git gadgets. A bunch of git extensions to"
  flag force || note "make your development more organized and productive.\n"

  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    note "This is not a git repository already. Let's start..."
    if git init >/dev/null 2>&1; then
      note "Git initialized in directory __$(pwd)__.\n"
    else
      die "Something went wrong. GIT cant't be initialized in this directory."
    fi
  fi

  flag force || note "Creating __.git/gadgets__ file."
  flag force || note "All extensions configuration stay here."
  flag force || note "See documentation for further information.\n"
  local root_path
  root_path=$(git stats --root-path)
  [ -e $root_path/.git/gadgets ] || (touch $root_path/.git/gadgets)

  if git_config_has_master && ! flag force; then
    master=$(git_get core.master)
  else
    branch_count=$(git_local_branches | wc -l)
    if [ "$branch_count" -eq 0 ]; then
      note "No branches exists. We need to create it."
      suggestion=$(git_get core.master || echo master)
    else
      note "You have these branchs:"
      flag defaults || git_local_branches | sed 's/^.*$/   - &/g'
      suggestion=
			for mybranch in $(git_get core.master) 'production' 'main' 'master'; do
				if git_local_branch_exists "$mybranch"; then
					suggestion="$mybranch"
					break
				fi
			done
    fi

    if flag defaults; then
      master=$suggestion
    else
      ask --default="$suggestion" --free-answer --question="Choose branch name for production (master) branch"
      master=${ask_answer}
    fi
  fi

  git_set core.master "$master"

  export MASTER_BRANCH="$master"
  export CURRENT_BRANCH="$master"

  if git_local_branch_exists "$master" && ! git rev_parse --quiet --verify HEAD>/dev/null 2>&1 ; then
    git symbolic-ref HEAD "refs/heads/$master"
  fi

  file="$(git stats --root-path)/README.md"
  [ -f $file ] || printf "#$(git stats --project-name)\n\nPowered by Git Gadgets." >> $file
  git_add $file

  local msg
  if flag new_gadgets_repo; then
    msg="Start using git gadgets."
  else
    msg="Reconfiguring git gadgets."
  fi
  git_commit gadgets "$msg"

  git_checkout "$master"

  note "Git gadgets initialized."
}

# Make sure we are in a valid repository of a vintage we understand,
# if we require to be in a git repository.
git_dir_init () {
	GIT_DIR=$(git rev-parse --git-dir) || exit
	if [ -z "$SUBDIRECTORY_OK" ]
	then
		test -z "$(git rev-parse --show-cdup)" || {
			exit=$?
			echo >&2 "You need to run this command from the toplevel of the working tree."
			exit $exit
		}
	fi
	test -n "$GIT_DIR" && GIT_DIR=$(cd "$GIT_DIR" && pwd) || {
		echo >&2 "Unable to determine absolute path of git directory"
		exit 1
	}
	: ${GIT_OBJECT_DIRECTORY="$(git rev-parse --git-path objects)"}
}

if test -z "$NONGIT_OK"
then
	git_dir_init
fi
