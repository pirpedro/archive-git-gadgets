#!/bin/bash

SUBDIRECTORY_OK="yes"

source $(git stats --script-location $0)/git-flow-common

git_get flow.prefix.feature >/dev/null 2>&1 || die "Flow is not using feature branches. Use 'git flow init -f' to reconfigure."
prefix=$(git_get flow.prefix.feature)

parse_args(){
  case "$1" in
    -h ) usage ;;
    * ) NAME="$1"
  esac

  if ! empty "$NAME"; then
    if startswith "$NAME" "$prefix"; then
      NAME=${NAME##$prefix}
    fi
    BRANCH="$prefix$NAME"
  fi
}

default(){
  list "$@"
}

help(){
USAGE='' && read -r -d '' USAGE <<'EOF'
feature

git flow feature [list]
git flow feature start
git flow feature finish
git flow feature publish
git flow feature track
git flow feature diff
git flow feature rebase
git flow feature delete

Manage your feature branches.

For more specific help type the command followed by -h
EOF
  usage
}

list(){
  USAGE="\
feature [list] [-h] [-v]

Lists all the existing feature branches in the local repository.

    -h   Show help
    -v   Verbose output
"
  parse_args "$@"
  local feature_branchs base develop_hash branch_hash
  feature_branchs=$(git_local_branches_with_prefix "$prefix")
  if empty $feature_branchs; then
    warn -f "No local feature branchs."
    warn -f "Use 'git flow feature start'."
    exit 1
  fi
  current_branch=$(git stats --long-current-branch)
  for branch in $feature_branchs; do
    base=$(git merge-base "$branch" "$DEVELOP_BRANCH")
    branch_hash=$(git rev-parse "$branch")
		develop_hash=$(git rev-parse "$DEVELOP_BRANCH")
    if equals "$branch" "$current_branch"; then
      printf "* "
    else
      printf "  "
    fi
    if flag verbose; then
      printf "${branch##$prefix} "
      if equals "$branch_hash" = "$develop_hash"; then
        printf "(no commits)"
      elif equals "$base" "$branch_hash"; then
        printf "(is behind $DEVELOP_BRANCH, can fast-forward)"
      elif equals "$base" "$develop_hash"; then
        printf "(based on develop)"
      else
        printf "(should need a rebase)"
      fi
    else
      printf "%s" "${branch##$prefix}"
    fi
    echo
  done

}

start(){
  USAGE="\
git flow feature start [-h] [-F] <name> [<base>]

Start new feature <name>, optionally basing it on <base> instead of <develop>
    -h         Show help
    --fetch    Fetch from origin before performing local operation
"

  for arg do
    shift
    case "$arg" in
      --fetch) set_flag fetch; ;;
      *) set -- "$@" "$arg"; ;;
    esac
  done
  parse_args "$@"
  base=${2:-$DEVELOP_BRANCH}

  require_local_branch "$base"
  ! empty "$NAME" || die "No branch name passed."
  flow_set_branch_base $BRANCH $base

  if flag fetch; then
    git_fetch "$ORIGIN" "$base"
  fi

  require_branch_absent "$BRANCH"

  # If the origin branch counterpart exists, assert that the local branch
	# isn't behind it (to avoid unnecessary rebasing)
  if git_remote_branch_exists "$ORIGIN/$base"; then
    require_branches_equal "$base" "$ORIGIN/$base"
  fi

  git_checkout $BRANCH $base;
  note "Branch $BRANCH created, based on $base."
  note "You are in branch $(git stats --long-current-branch)."
  note "Use 'git flow feature finish $NAME' when done."
}

finish(){
  USAGE="\
  git flow feature finish [-h] [-F] [-r] [-p] [-k] [-D] [-S] [--no-ff] <name|nameprefix>

  Finish feature <name>
      -h                Show this help
      --fetch            Fetch from origin before performing finish
      --rebase           Rebase before merging
      --preserve-merges  Preserve merges while rebasing
      --push               Push to origin after performing finish
      --keep             Keep branch after performing finish
      --squash           Squash feature during merge
  "
  for arg do
    shift
    case "$arg" in
      --fetch) set_flag fetch; ;;
      --rebase) set_flag rebase; ;;
      --preserve-merges) set_flag preservemerge ;;
      --push) set_flag push ;;
      --keep) set_flag keep; ;;
      *) set -- "$@" "$arg"; ;;
    esac
  done
  parse_args "$@"
  if empty "$NAME"; then
    NAME=$(git stats --long-current-branch)
    BRANCH=$NAME
  fi
  require_branch_prefix "$BRANCH" "$prefix"
  require_branch "$BRANCH"
  base=$(flow_get_branch_base "$BRANCH")
  base=${base:-$DEVELOP_BRANCH}
  require_local_branch "$base"

  # Sanity checks
	require_clean_working_tree

  # We always fetch the Branch from Origin
	# This is done to avoid possible commits on the remote that are not
	# merged into the local branch
	if git_remote_branch_exists "$ORIGIN/$BRANCH"; then
		git_fetch "$ORIGIN" "$BRANCH"
	fi

  # Update local branches with remote branches
	if flag fetch; then
		git_fetch "$ORIGIN" "$base"
	fi

  # Check if the local branches have all the commits from the remote branches
	if git_remote_branch_exists "$ORIGIN/$BRANCH"; then
			require_branches_equal "$BRANCH" "$ORIGIN/$BRANCH"
	fi
	if git_remote_branch_exists "$ORIGIN/$base"; then
		require_branches_equal "$base" "$ORIGIN/$base"
	fi

  # If the user wants to rebase, do that first
	if flag rebase; then
    local _rebase_opts=""
		if flag preservemerge; then
			_rebase_opts="$_rebase_opts -p"
		fi
		if ! git flow feature rebase $_rebase_opts "$NAME"; then
			warn "Finish was aborted due to conflicts during rebase."
			warn "Please finish the rebase manually now."
			warn "When finished, re-run:"
			warn "    git flow feature finish '$NAME' '$base'"
			exit 1
		fi
	fi

  # Merge into BASE
	git_checkout "$base" || die "Could not check out branch '$base'."
  if [ "$(git rev-list -n2 "$base..$BRANCH" | wc -l)" -eq 1 ]; then
				git merge --ff "$candidate_branch"
	else
				git merge --no-ff "$candidate_branch"
  fi

  if [ $? -ne 0 ]; then
    warn -f "We detected a merge conflict"
    warn -f "Use 'git mergetool' and 'git commit' before try again. "
    exit 1
  fi

  flow_unset_branch_base "$BRANCH"
  finish_cleanup

}

finish_cleanup(){
  require_branch "$BRANCH"
  require_clean_working_tree

  if ! flag keep; then
    if git_remote_branch_exists "$ORIGIN/$BRANCH"; then
      git_remote_branch_delete "$BRANCH"
    fi

    if equals "$BRANCH" "$(git stats --long-current-branch)"; then
      git_checkout "$base" || die "Could not checkout $base."
    fi

    git branch -d "$BRANCH" && flow_remove_branch_section "$BRANCU"
  fi

  if flag push; then
    git push "$ORIGIN" "$base" || die "Could not push changes from $base to $ORIGIN."
  fi

  note "Feature __${BRANCH}__ was merged into __${base}__."
  if ! flag keep; then
    note "Feature __${BRANCH}__ was removed."
  fi
  note "You are in branch $(git stats --long-current-branch)."

}

publish(){
  USAGE="\
git flow feature publish [-h] [<name>]

Publish feature branch <name> on $ORIGIN.
When <name> is omitted the current branch is used, but only if it's a feature branch.

    -h          Show this help
"
  # Parse arguments
  parse_args "$@"

  # Use current branch if no name is given
  if EMPTY "$NAME"; then
    NAME=$(git stats --long-current-branch)
    BRANCH=$NAME
  fi

  # Sanity checks
  require_clean_working_tree
  require_branch "$BRANCH"

  # Create remote branch with remote tracking
  git push -u "$ORIGIN" "$BRANCH:$BRANCH"
  git_fetch "$ORIGIN" "$BRANCH" || die "Could not fetch branch '$BRANCH' from remote '$ORIGIN'."
  git_checkout "$BRANCH" || die "Could not check out branch '$BRANCH'."

  note "- The remote branch '$BRANCH' was created or updated"
  note "- The local branch '$BRANCH' was configured to track the remote branch"
  note "You are in branch $(git stats --long-current-branch)."
}

track() {
	USAGE="\
git flow feature track [-h] <name>

Start tracking feature <name> that is shared on $ORIGIN

    -h         Show this help
"
	# Parse arguments
	parse_args "$@"

	! empty "$NAME" || die "No branch name passed."

	# Sanity checks
	require_clean_working_tree
	require_local_branch_absent "$BRANCH"
require_remote_branch "$ORIGIN/$BRANCH"

	# Create tracking branch
	git_checkout "$BRANCH" "$ORIGIN/$BRANCH" || die "Could not create '$BRANCH'."

	note "A new remote tracking branch '$BRANCH' was created"
	note "You are in branch $(git stats --long-current-branch)."
}

diff() {
	USAGE="\
git flow feature diff [-h] [<name|nameprefix>]

Show all changes in <name> that are not in the base
    -h          Show this help
"
	local base

	# Parse arguments
	parse_args "$@"

  # Use current branch if no name is given
  if EMPTY "$NAME"; then
    NAME=$(git stats --long-current-branch)
    BRANCH=$NAME
  fi

	base=$(flow_get_branch_base $BRANCH)
	base=${base:-$DEVELOP_BRANCH}

	git diff "$base..$BRANCH"
}

rebase() {
  USAGE="\
  git flow feature rebase [-h] [-i] [-p] [<name|nameprefix>]

  Rebase <name> on <base_branch>
      -h                 Show this help
      -i                 Do an interactive rebase
      --preserve-merges  Preserve merges
  "

  for arg do
    shift
    case "$arg" in
      -i) set_flag interactive; ;;
      --preserve-merges) set_flag preservemerges; ;;
      *) set -- "$@" "$arg"; ;;
    esac
  done
	# Parse arguments
	parse_args "$@"

	if empty "$NAME"; then
    NAME=$(git stats --long-current-branch)
    BRANCH=$NAME
  fi
  require_branch_prefix "$BRANCH" "$prefix"
  require_branch "$BRANCH"
  base=$(flow_get_branch_base "$BRANCH")
  base=${base:-$DEVELOP_BRANCH}
  require_local_branch "$base"

	require_clean_working_tree

	git_checkout "$BRANCH"  || die "Could not check out branch $candidate_branch."
	if flag interactive; then
		opts="$opts -i"
	fi
	if flag preservemerges; then
		opts="$opts -p"
	fi
	git rebase $opts "$base"
}

delete(){
  USAGE="\
git flow feature delete [-h] [-f] [-r] <name>

Delete a given feature branch

    -h          Show this help
    --remote    Delete remote branch
"
	local current_branch

	# Parse arguments
	parse_args "$@"

	! empty "$NAME" || die "No branch name passed."

	# Sanity checks
	require_branch "$BRANCH"

	BASE_BRANCH=$(flow_get_branch_base $BRANCH)
	BASE_BRANCH=${BASE_BRANCH:-$DEVELOP_BRANCH}

	current_branch=$(git stats --long-current-branch)
	# We can't delete a branch we are on, switch to the develop branch.
	if equals "$BRANCH" "$current_branch"; then
		require_clean_working_tree
		if git_local_branch_exists "$BASE_BRANCH"; then
			git_checkout "$BASE_BRANCH"
		else
			git_checkout "$DEVELOP_BRANCH" || die "Could not check out branch '$DEVELOP_BRANCH'."
		fi
	fi

	if git_is_branch_merged_into "$BRANCH" "$BASE_BRANCH"; then
		git branch -d "$BRANCH" || die "Could not delete the $BRANCH."
		if flag remote; then
			git push "$ORIGIN" :"$BRANCH" || die "Could not delete the remote $BRANCH in $ORIGIN."
		fi
	else
		die "Feature branch '$BRANCH' has been not been merged yet. "
	fi

	flow_unset_branch_base"$BRANCH"

	note "Feature branch '$BRANCH' has been deleted."
	flag remote && note "Feature branch '$BRANCH' in '$ORIGIN' has been deleted."
	note "You are in branch $(git stats --long-current-branch)."
}
