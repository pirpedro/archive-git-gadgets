#!/bin/bash

#Colors
NC=`echo -e "\033[0m"`
BLACK="\033[0;30m"
RED="\033[0;31m"
GREEN="\033[0;32m"
ORANGE="\033[0;33m"
BLUE="\033[0;34m"
PURPLE="\033[0;35m"
CYAN="\033[0;36m"
LGRAY="\033[0;37m"
DGRAY="\033[1;30m"
LRED="\033[1;31m"
LGREEN="\033[1;32m"
YELLOW="\033[1;33m"
LBLUE="\033[1;34m"
LPURPLE="\033[1;35m"
LCYAN="\033[1;36m"
WHITE="\033[1;37m"

#flags
FLAG_TRUE=0
FLAG_FALSE=1
FLAG_ERROR=2
#ask_color=`echo -e ${GREEN}`
#warn_color=`echo -e ${YELLOW}`
#note_color=`echo -e ${CYAN}`
#highlight=`echo -e ${WHITE}`
question_color=${GREEN}
warn_color=${YELLOW}
note_color=${CYAN}
highlight=${WHITE}

QUESTION_FLAG="${question_color}?"
WARN_FLAG="${warn_color}!"
NOTE_FLAG="${note_color}‚ùØ"

#string matchings
startswith() { [ "$1" != "${1#$2}" ]; }
endswith() { [ "$1" != "${1%$2}" ]; }
contains() {
  case "$1" in
    *$2* ) return ${FLAG_TRUE}; ;;
    * ) return ${FLAG_FALSE}; ;;
  esac
}

check_boolean(){
  case "$1" in
    [yY] | [yY][eE][sS] | [oO][nN] | ${FLAG_TRUE} ) return ${FLAG_TRUE} ; ;;
    [nN] | [nN][oO] | [oO][fF][fF] | ${FLAG_FALSE} ) return ${FLAG_FALSE}; ;;
    [*] ) return ${FLAG_ERROR}; ;;
  esac
}

#outputs
verbosity(){
   if check_boolean "$1"; then
      export VERBOSE_MODE=1;
   fi
}

log(){
  for arg do
    shift
    case "$arg" in
      -f | --force) local force=${FLAG_TRUE} ;;
      *) set -- "$@" "$arg" ;;
    esac
  done
[[ -z "$VERBOSE_MODE" && -z "$force" ]] || echo "$@";
}

#
# Generate colored message, conditional do verbose mode
# and accept highlight with pattern '__PATTERN__'
#
# Params
# --color=<value>
# --flag=<value>
# --highlight=<value> default value ${highlight}
__notify(){
  for arg do
    shift
    case "$arg" in
      --color=* )
          local color=`echo -e ${arg##--color=}`; ;;
      --flag=* )
          local flag=`echo -e ${arg##--flag=}`; ;;
      --highlight=* ) local highlight_color=${arg##--highlight=}; ;;
      *) set -- "$@" "$arg"; ;;
    esac
  done
  highlight_color=`echo -e ${highlight_color:-$highlight}`
  msg="$arg" #msg is the last element of iteration
  set -- "${@:1:$(($#-1))}" #remove last argument
  msg=`sed -r "s/(__)([^_]+)(__)/${highlight_color}\2${color}/g;" <<< "$msg"`
  log -e "$@" "${flag}$msg${NC}"
}

note(){ __notify --color="${note_color}" --flag="${NOTE_FLAG}" "$@"; }
question(){ __notify --color="${question_color}" --flag="${QUESTION_FLAG}" "$@"; }
warn(){ __notify --color="${warn_color}" --flag="${WARN_FLAG}" "$@";}
die() { warn "Fatal: $@"; exit 1; }

ask(){
  unset ask_answer
  for arg do
    shift
    case "$arg" in
      --question=* )
          local question_msg=${arg##--question=}; ;;
      --options=* )
          local options=${arg##--options=}; ;;
      --default=* ) local default_value=${arg##--default=}; ;;
    esac
  done
  options_string=`sed -r 's/,/|/g' <<< "$options"`
  question -f -n "${question_msg} [${options_string}]: "
  read answer
  answer=${answer:-$default_value}
  old_ifs=${IFS}; IFS=","; array=($options); IFS=${old_ifs}
  for ((i = 0; i < ${#array[@]}; i++)); do
    if startswith "${array[i]}" "${answer}"; then
      export ask_answer=${array[i]}
      break
    fi
  done
}
ask_boolean(){
  msg=$1
  default=${2:-$FLAG_TRUE}
  if check_boolean "$default"; then
    default_string="[__Yy__]: "
  else
    default_string="[__Nn__]: "
  fi

  question -n "$msg ${default_string}"
  read answer
  answer=${answer:-default}
#  if convert_boolean "$answer" == "$default"; then
}
verbosity on
ask --question="Criar branch" --options="no branch,release,hotfix" --default="hotfix"
echo $ask_answer

location(){
  case $(uname -s) in
  Linux)
  	echo $(dirname "$(readlink -e "$0")")
  	;;
  FreeBSD|OpenBSD|NetBSD)
  	echo $(dirname "$(realpath "$0")")
  	;;
  Darwin)
  	PRG="$0"
  	while [ -h "$PRG" ]; do
  		link=$(readlink "$PRG")
  		if expr "$link" : '/.*' > /dev/null; then
  			PRG="$link"
  		else
  			PRG="$(dirname "$PRG")/$link"
  		fi
  	done
  	echo $(dirname "$PRG")
  	;;
  *MINGW*)
  	echo $(dirname "$(echo "$0" | sed -e 's,\\,/,g')")
  	pwd () {
  		builtin pwd -W
  	}
  	;;
  *)
  	echo GITFLOW_DIR=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")
  	;;
  esac
}
