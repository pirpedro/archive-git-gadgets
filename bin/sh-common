#!/bin/bash

#Colors
NC=`echo -e "\033[0m"`
BLACK="\033[0;30m"
RED="\033[0;31m"
GREEN="\033[0;32m"
ORANGE="\033[0;33m"
BLUE="\033[0;34m"
PURPLE="\033[0;35m"
CYAN="\033[0;36m"
LGRAY="\033[0;37m"
DGRAY="\033[1;30m"
LRED="\033[1;31m"
LGREEN="\033[1;32m"
YELLOW="\033[1;33m"
LBLUE="\033[1;34m"
LPURPLE="\033[1;35m"
LCYAN="\033[1;36m"
WHITE="\033[1;37m"

#flags
FLAG_TRUE=0
FLAG_FALSE=1
FLAG_ERROR=2
#ask_color=`echo -e ${GREEN}`
#warn_color=`echo -e ${YELLOW}`
#note_color=`echo -e ${CYAN}`
#highlight=`echo -e ${WHITE}`
question_color=${GREEN}
warn_color=${YELLOW}
note_color=${CYAN}
highlight=${WHITE}

QUESTION_FLAG="${question_color}?"
WARN_FLAG="${warn_color}!"
NOTE_FLAG="${note_color}‚ùØ"

#string matchings
startswith() { [ "$1" != "${1#$2}" ]; }
endswith() { [ "$1" != "${1%$2}" ]; }
equals() { [ "$1" == "$2" ]; }
contains() {
  case "$1" in
    *$2* ) return ${FLAG_TRUE}; ;;
    * ) return ${FLAG_FALSE}; ;;
  esac
}

#check if a file or a variable is empty
empty(){
  if [ -f "$1" ]; then
    [ ! -s "$1" ]
  else
    [ -z "$1" ]
  fi
}

check_boolean(){
  case "$1" in
    [yY] | [yY][eE][sS] | [oO][nN] | ${FLAG_TRUE} ) return ${FLAG_TRUE} ; ;;
    [nN] | [nN][oO] | [oO][fF][fF] | ${FLAG_FALSE} ) return ${FLAG_FALSE}; ;;
    [*] ) return ${FLAG_ERROR}; ;;
  esac
}

#outputs
verbosity(){
   if check_boolean "$1"; then
      set_global_flag verbosity
   fi
}

log(){
  local force
  for arg do
    shift
    case "$arg" in
      -f | --force) force=${FLAG_TRUE} ;;
      *) set -- "$@" "$arg" ;;
    esac
  done
  ! flag verbosity && test -z "$force" || echo "$@";
}

#
# Generate colored message, conditional do verbose mode
# and accept highlight with pattern '__PATTERN__'
#
# Params
# --color=<value>
# --flag=<value>
# --highlight=<value> default value ${highlight}
__notify(){
  for arg do
    shift
    case "$arg" in
      --color=* )
          local color=`echo -e ${arg##--color=}`; ;;
      --flag=* )
          local flag=`echo -e ${arg##--flag=}`; ;;
      --highlight=* ) local highlight_color=${arg##--highlight=}; ;;
      *) set -- "$@" "$arg"; ;;
    esac
  done
  highlight_color=`echo -e ${highlight_color:-$highlight}`
  msg="$arg" #msg is the last element of iteration
  set -- "${@:1:$(($#-1))}" #remove last argument
  msg=`sed -r "s/(__)([^_]+)(__)/${highlight_color}\2${color}/g;" <<< "$msg"`
  log -e "$@" "${flag}$msg${NC}"
}

note(){ __notify --color="${note_color}" --flag="${NOTE_FLAG}" "$@"; }
question(){ __notify --color="${question_color}" --flag="${QUESTION_FLAG}" "$@"; }
warn(){ __notify --color="${warn_color}" --flag="${WARN_FLAG}" "$@";}
die() { warn "Fatal: $@"; exit 1; }

#
# Make a question
#
# Params:
#
# --question=<value>         question string
# --options=<value>          a comma separated string with options
# --default=<default_value   choose a default answer throught options list
# --boolean                  create a boolean (yes|no) question
#
ask(){
  unset ask_answer
  local ask_default_value question_msg options
  for arg do
    shift
    case "$arg" in
      --question=* )
          question_msg=${arg##--question=}; ;;
      --options=* )
          options=${arg##--options=}; ;;
      --default=* ) ask_default_value=${arg##--default=}; ;;
      --boolean ) options="yes,no"; ask_default_value=${ask_default_value:-"yes"}; ;;
      --free-answer ) set_flag free; ;;
    esac
  done
  if [[ -z "$options" &&  -n "$ask_default_value" ]]; then
    options="$ask_default_value"
  fi
  options_string=`sed -r 's/,/|/g' <<< "$options"`
  question -f -n "${question_msg} [${options_string}]: "
  read answer
  answer=${answer:-$ask_default_value}
  old_ifs=${IFS}; IFS=","; array=($options); IFS=${old_ifs}
  for ((i = 0; i < ${#array[@]}; i++)); do
    if startswith "${array[i]}" "${answer}"; then
      export ask_answer=${array[i]}
      return
    fi
  done
  if flag free; then
    export ask_answer=${answer:-$ask_default_value}
    unset_flag free
    return
  fi
  export ask_answer=${ask_default_value}
}

#
# Create a boolean question
#
# ask_boolean "msg" [FLAG_TRUE-default|FLAG_FALSE]
#
# check answer "yes" or "no" in variable ask_answer
ask_boolean(){
  local msg=$1
  local default=${2:-$FLAG_TRUE}
  local default_string
  if check_boolean "$default"; then
    default_string="yes"
  else
    default_string="no"
  fi
  ask --question="$msg" --default="${default_string}" --boolean
}

location(){
  case $(uname -s) in
  Linux)
  	echo $(dirname "$(readlink -e "$1")")
  	;;
  FreeBSD|OpenBSD|NetBSD)
  	echo $(dirname "$(realpath "$1")")
  	;;
  Darwin)
  	PRG="$1"
  	while [ -h "$PRG" ]; do
  		link=$(readlink "$PRG")
  		if expr "$link" : '/.*' > /dev/null; then
  			PRG="$link"
  		else
  			PRG="$(dirname "$PRG")/$link"
  		fi
  	done
  	echo $(dirname "$PRG")
  	;;
  *MINGW*)
  	echo $(dirname "$(echo "$1" | sed -e 's,\\,/,g')")
  	pwd () {
  		builtin pwd -W
  	}
  	;;
  *)
  	echo $(dirname "$(echo "$1" | sed -e 's,\\,/,g')")
  	;;
  esac
}

flag(){ local varname="FLAG_$1"; [ "${!varname}" == "${FLAG_TRUE}" ]; }
unset_flag(){ unset "FLAG_$1"; }
set_flag(){
  local flag
  flag=${2:-$FLAG_TRUE}
  if check_boolean "$flag"; then
    eval "FLAG_$1=$FLAG_TRUE";
  else
    unset_flag "$1"
  fi
}
set_global_flag(){
  local flag
  flag=${2:-${FLAG_TRUE}}
  if check_boolean "${flag}"; then
    export "FLAG_$1=${FLAG_TRUE}";
  else
    unset_flag "$1"
  fi
}
